{"name":"Basic String my owns","fileName":"My Flimsy Drawer Notebook.json","createdAt":"2024-07-09T16:41:21.713Z","cells":[{"id":"3f1c1bc18e7075fa","type":"markdown","content":"**Notes**\n* Add some notes here\n* Use markdown\n* Some thing about redis"},{"id":"1720620559973","type":"markdown","content":"# BASIC STRING"},{"id":"1720620294084","type":"redis","content":"SET msg 'Hello'"},{"id":"1720620592344","type":"redis","content":"GET msg"},{"id":"1720621080517","type":"markdown","content":"- There are many kind of command in redis, however, some of them have the same function. \n- if you read docs in redis.com, GETEX key [ EX | PX] you only can use either EX and PX.\n"},{"id":"1720621521717","type":"redis","content":"SET color RED\n\nSET color green GET\n\nGET color"},{"id":"1720623707770","type":"redis","content":"SET kklk 'Already exists' XX\n\nSET color 'yellow' xx\n\nget color\n\nset color 'green' nx"},{"id":"1720624826785","type":"redis","content":"SET color red EX 2\nGET color"},{"id":"1720624871340","type":"redis","content":"GET color"},{"id":"1720625730912","type":"markdown","content":"> the main reason that we have to delete automatically is that: for instance, you call API to get headlines, then, you retrieve redis cache if its empty, we will query traditional database. After getting information, in case customers returning this page, we can save this to redis 10 seconds, as a result, customers can get faster response. Furthermore,  we can save memory for redis and prevent redis caching from out of memory."},{"id":"1720625724999","type":"redis","content":"SETEX msg 2 red"},{"id":"1720630851703","type":"redis","content":"GET msg"},{"id":"1720630948961","type":"redis","content":"MSET color red msg 'Hello!'\nGET color\nGET msg\n\nMGET color msg"},{"id":"1720630947445","type":"redis","content":"get color\n\ndel color\n\nget color"},{"id":"1720667719229","type":"redis","content":"set car \"toyota\"\n\nGETRANGE car 0 2\n"},{"id":"1720667850516","type":"redis","content":"get car \n\nSETRANGE car 4 \"replace\" \n\nget car"},{"id":"1720670753561","type":"markdown","content":"### trick dealing with limited string in attribute database\n> We can use redis to update database and set, get information. As we have a 9 million records in database, each rows will have limited attribute in color : red, green,blue;therefore, queries will lead to the app running slowly.  Because of limited typed of output, we can encode that red->a, green -> b, blue ->c; then redis will stored item1: akg(k,g can be the result of encode from other feature ) ; item2: beg. Hence they can reduce number of memory usage in redis and udate faster.\nFor example we can use SETRANGE item1 0 b => item1: bkg (update easily) (lesson 15)\n> Ví dụ db có rất nhiều user, 1 user mà vào trang chỉnh sửa cá nhân => caching lại và đợi update => đỡ phải query update lại vào trong database => và autoremove trong 1 khoảng tgian => faster."},{"id":"1720670050604","type":"redis","content":"SET age 20\n\nINCR age\n\nGET age\n\nINCRBY age 20\n\nGET age\n\nINCRBYFLOAT age 1.12 "},{"id":"1720672504621","type":"markdown","content":"### Why we need using INCRBY? There are two reasons\n-  First, INCRBY will implement your command action. If you dont use this command, you have to Get key value and set key value, you have to request two times, which can lead to time consuming.\n- Secondly, multiple requests from different users at the same time can make a huge issue for updating database. For example, two user upvote for same post at the same time, if we use get and set, two user will receive a same vote is 20 and upvote to 21 (User 1 and user 2 receive 20, using set 21 ), which is a mistake upvote. Whereas, if we use incr, redis is (xử lý đồng bộ) each requests will be solved in  a row(User 1 update : 20 +1, User2 update 21+1)"}],"id":"41f91a132d764117"}